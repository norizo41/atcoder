'''
■AtCoder Educational DP Contest A - Frog 1
N個の足場があって、(i=0,1,...,N-1)番目の
足場の高さはhiで与えられます。最初0番目の足場にカエルがいて、
以下のいずれかの行動を繰り返してN-1番目の足場を目指します。
    ●足場iから足場i+1へと移動する(コストは|h_i-h_i+1|)
    ●足場iから足場i+2へと移動する(コストは|h_i-h_i+2|)
カエルがN-1番目の足場にたどり着くまでに
要するコストの総和の最小値を求めてください。
'''

'''
入力
'''
N = int(input())
h = list(map(int, input().split()))

'''
緩和処理を実現するための関数chminを定義する
'''
def chmin(a, b):
    if a > b:
        a = b
    return a

'''
十分大きな値とする
'''
INF = 2 ** 60
'''
配列dpを定義(配列全体を無限大に表す値に初期化)
'''
dp = [INF] * N
'''
初期条件
'''
dp[0] = 0;

'''
今回は、Frog問題を「メモ化再帰による方法」で解く
'''

'''
rec(i)：足場0から足場iに至るまでの最小コストを算出する再帰関数
'''
def rec(i):
    
    '''DPの値が更新されていたらそのままリターン'''
    if dp[i] < INF:
        return dp[i]
    
    '''ベースケース：足場0のコストは0'''
    if i == 0:
        return 0
    
    '''答えを格納する変数をINFに初期化する'''
    res = INF
    
    '''頂点i-1から来た場合'''
    res = chmin(res, rec(i - 1) + abs(h[i] - h[i-1]))
    
    '''頂点i-2から来た場合'''
    if i > 1:
        res = chmin(res, rec(i-2) + abs(h[i] - h[i-2]))
    
    '''結果をメモ化する'''
    dp[i] = res
    
    '''答えを返す'''
    return res



'''
答えを出力
'''
print(rec(N-1))
